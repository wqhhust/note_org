
* org mode

** Export

*** html setting

**** control superscripts
Add the following at the beginning of your file.
#+OPTIONS: ^:nil
^:
Toggle TeX-like syntax for sub- and superscripts. If you write "^:{}", ‘a_{b}’ will be interpreted, but the simple ‘a_b’ will be left as it is (org-export-with-sub-superscripts). 
**** outline level
 #+OPTIONS: H:5
The above means html will export 5 level outline. And the default is 3 level outline.

The outline structure of the document as described in Document Structure, forms the basis for defining sections of the exported document. However, since the outline structure is also used for (for example) lists of tasks, only the first three outline levels will be used as headings. Deeper levels will become itemized lists. You can change the location of this switch globally by setting the variableorg-export-headline-levels, or on a per-file basis with a line

** PlantUML (draw digram) 
Setup
With the latest version of Org-mode setup consists of adding plantuml to `org-babel-load-languages' with code like the following or through the customization interface.
;; active Org-babel languages
(org-babel-do-load-languages
 'org-babel-load-languages
 '(;; other Babel languages
   (plantuml . t)))
Then download the jar file save it somewhere on your system, set `org-plantuml-jar-path' to point to this file.
(setq org-plantuml-jar-path
      (expand-file-name "~/src/org/contrib/scripts/plantuml.jar"))
Usage
see http://plantuml.sourceforge.net/ for a variety of example usages, the following code block is an example of usage from within an Org-mode file.
#+begin_src plantuml :file tryout.png
  Alice -> Bob: synchronous call
  Alice ->> Bob: asynchronous call
#+end_src
#+results:file:tryout.png
** to-do

** Table

*** How to move to end of cell
In org-mode, table cells are called *fields*. C-h a org field outputs a list of commands related to org tables fields.
The function org-forward-sentence is bound to M-e. When inside a table, it will jump to the end of the current field.
http://emacs.stackexchange.com/questions/18362/how-to-move-to-the-end-of-current-cell
* magit
** git command
*** get the commit history for a sepecific developer
git log --author=daniel
** key biddings
good link http://magit.vc/manual/magit-refcard.pdf
Having decided that Magit is the bee’s knees you’ll probably want to know the keyboard shortcuts.  Here are the most common ones:
C-c g Start magit (M-x magit-status)
s   Stage file
S   Stage all files
u   Unstage file
c   Commit staged files. C-c C-c after writing commit message or C-c C-k to abort. C-c C-a sdlkfjlkdfj
b b   To switch to a branch
b m   Rename branch
b d   Delete branch
b v   List branches (can checkout from resultant screen using RET)
P P   Git push
f f   Git fetch
F F   Git pull
TAB   Shows diff of file in the list or expand collapse section. Stage and unstage actually work on bits of the diff as well.
i   Ignore file (adds to .gitignore)
k   Delete. Deletes untracked file and stashes (on section header it deletes all untracked files). If you’re positioned in a diff for an uncommited file you can also delete just the hunk.  (discard a file)
l l   Show history
l L   Show history in verbose format
t t   Make lightweight tag
t a   Make annotated tag
x   Revert commit history to entered revision
z z   Create a stash
a a
A   Apply the stash and pop it off the stash list
z s   Creates a snapshot (the stash gets created but the working tree is not deleted.
w   Show how other branches related to the current one
m m   Start merging. In the event of conflicts resolve changes using e then stage with s.
R   Starts a rebase R c will continue a rebase. Stage resolved conflicts before continuing.
** show log history for a specific dev in magit
in the magit buffer, press "L", then it will show lots of options, and then press "=a" to input the dev name, press enter again to show all the logs for that author
** show change in a commit in the log history
in the log history, use "d"+"d" to see the history for a commit under the cursor. 
* vi
** key bidding
Vim Commands Cheat Sheet

How to Exit

:q[uit]	Quit Vim. This fails when changes have been made.
:q[uit]!	Quit without writing.
:cq[uit]	Quit always, without writing.
:wq	Write the current file and exit.
:wq!	Write the current file and exit always.
:wq {file}	Write to {file}. Exit if not editing the last
:wq! {file}	Write to {file} and exit always.
:[range]wq[!]	[file] Same as above, but only write the lines in [range].
ZZ	Write current file, if modified, and exit.
ZQ	Quit current file and exit (same as ":q!").
Editing a File

:e[dit]	Edit the current file. This is useful to re-edit the current file, when it has been changed outside of Vim.
:e[dit]!	Edit the current file always. Discard any changes to the current buffer. This is useful if you want to start all over again.
:e[dit] {file}	Edit {file}.
:e[dit]! {file}	Edit {file} always. Discard any changes to the current buffer.
gf	Edit the file whose name is under or after the cursor. Mnemonic: "goto file".
Inserting Text

a	Append text after the cursor [count] times.
A	Append text at the end of the line [count] times.
i	Insert text before the cursor [count] times.
I	Insert text before the first non-blank in the line [count] times.
gI	Insert text in column 1 [count] times.
o	Begin a new line below the cursor and insert text, repeat [count] times.
O	Begin a new line above the cursor and insert text, repeat [count] times.
Inserting a file

:r[ead] [name]	Insert the file [name] below the cursor.
:r[ead] !{cmd}	Execute {cmd} and insert its standard output below the cursor.
Deleting Text

<Del> or
x	Delete [count] characters under and after the cursor
X	Delete [count] characters before the cursor
d{motion}	Delete text that {motion} moves over
dd	Delete [count] lines
D	Delete the characters under the cursor until the end of the line
{Visual}x or
{Visual}d	Delete the highlighted text (for {Visual} see Selecting Text).
{Visual}CTRL-H or
{Visual}	When in Select mode: Delete the highlighted text
{Visual}X or
{Visual}D	Delete the highlighted lines
:[range]d[elete]	Delete [range] lines (default: current line)
:[range]d[elete] {count}	Delete {count} lines, starting with [range]
Changing (or Replacing) Text

r{char}	replace the character under the cursor with {char}.
R	Enter Insert mode, replacing characters rather than inserting
~	Switch case of the character under the cursor and move the cursor to the right. If a [count] is given, do that many characters.
~{motion}	switch case of {motion} text.
{Visual}~	Switch case of highlighted text
Substituting

:[range]s[ubstitute]/{pattern}/{string}/[c][e][g][p][r][i][I] [count]	For each line in [range] replace a match of {pattern} with {string}.
:[range]s[ubstitute] [c][e][g][r][i][I] [count] :[range]&[c][e][g][r][i][I] [count]	Repeat last :substitute with same search pattern and substitute string, but without the same flags. You may add extra flags
The arguments that you can use for the substitute commands:
[c]  Confirm each substitution.  Vim positions the cursor on the matching
  string.  You can type:
      'y'      to substitute this match
      'n'      to skip this match
         to skip this match
      'a'      to substitute this and all remaining matches {not in Vi}
      'q'      to quit substituting {not in Vi}
      CTRL-E  to scroll the screen up {not in Vi}
      CTRL-Y  to scroll the screen down {not in Vi}.
[e]     When the search pattern fails, do not issue an error message and, in
  particular, continue in maps as if no error occurred.  
[g]  Replace all occurrences in the line.  Without this argument,
  replacement occurs only for the first occurrence in each line.
[i]  Ignore case for the pattern.  
[I]  Don't ignore case for the pattern.  
[p]  Print the line containing the last substitute.
Copying and Moving Text

"{a-zA-Z0-9.%#:-"}	Use register {a-zA-Z0-9.%#:-"} for next delete, yank or put (use uppercase character to append with delete and yank) ({.%#:} only work with put).
:reg[isters]	Display the contents of all numbered and named registers.
:reg[isters] {arg}	Display the contents of the numbered and named registers that are mentioned in {arg}.
:di[splay] [arg]	Same as :registers.
["x]y{motion}	Yank {motion} text [into register x].
["x]yy	Yank [count] lines [into register x]
["x]Y	yank [count] lines [into register x] (synonym for yy).
{Visual}["x]y	Yank the highlighted text [into register x] (for {Visual} see Selecting Text).
{Visual}["x]Y	Yank the highlighted lines [into register x]
:[range]y[ank] [x]	Yank [range] lines [into register x].
:[range]y[ank] [x] {count}	Yank {count} lines, starting with last line number in [range] (default: current line), [into register x].
["x]p	Put the text [from register x] after the cursor [count] times.
["x]P	Put the text [from register x] before the cursor [count] times.
["x]gp	Just like "p", but leave the cursor just after the new text.
["x]gP	Just like "P", but leave the cursor just after the new text.
:[line]pu[t] [x]	Put the text [from register x] after [line] (default current line).
:[line]pu[t]! [x]	Put the text [from register x] before [line] (default current line).
Undo/Redo/Repeat

u	Undo [count] changes.
:u[ndo]	Undo one change.
CTRL-R	Redo [count] changes which were undone.
:red[o]	Redo one change which was undone.
U	Undo all latest changes on one line. {Vi: while not moved off of it}
.	Repeat last change, with count replaced with [count].
Moving Around

Basic motion commands:

        k              
      h   l      
        j             
h or
[count] characters to the left (exclusive).
l or
or
[count] characters to the right (exclusive).
k or
or
CTRL-P	[count] lines upward
j or
or
CTRL-J or
or
CTRL-N	[count] lines downward (linewise).
0	To the first character of the line (exclusive).
<Home>	To the first character of the line (exclusive).
^	To the first non-blank character of the line
$ or
<End>	To the end of the line and [count - 1] lines downward
g0 or
g<Home>	When lines wrap ('wrap on): To the first character of the screen line (exclusive). Differs from "0" when a line is wider than the screen. When lines don't wrap ('wrap' off): To the leftmost character of the current line that is on the screen. Differs from "0" when the first character of the line is not on the screen.
g^	When lines wrap ('wrap' on): To the first non-blank character of the screen line (exclusive). Differs from "^" when a line is wider than the screen. When lines don't wrap ('wrap' off): To the leftmost non-blank character of the current line that is on the screen. Differs from "^" when the first non-blank character of the line is not on the screen.
g$ or
g<End&gr;	When lines wrap ('wrap' on): To the last character of the screen line and [count - 1] screen lines downward (inclusive). Differs from "$" when a line is wider than the screen. When lines don't wrap ('wrap' off): To the rightmost character of the current line that is visible on the screen. Differs from "$" when the last character of the line is not on the screen or when a count is used.
f{char}	To [count]'th occurrence of {char} to the right. The cursor is placed on {char} (inclusive).
F{char}	To the [count]'th occurrence of {char} to the left. The cursor is placed on {char} (inclusive).
t{char}	Till before [count]'th occurrence of {char} to the right. The cursor is placed on the character left of {char} (inclusive).
T{char}	Till after [count]'th occurrence of {char} to the left. The cursor is placed on the character right of {char} (inclusive).
;	Repeat latest f, t, F or T [count] times.
,	Repeat latest f, t, F or T in opposite direction [count] times.
- <minus>	[count] lines upward, on the first non-blank character (linewise).
+ or
CTRL-M or
<CR>	[count] lines downward, on the first non-blank character (linewise).
_ <underscore>	[count] - 1 lines downward, on the first non-blank character (linewise).
<C-End> or
G	Goto line [count], default last line, on the first non-blank character.
<C-Home> or
gg	Goto line [count], default first line, on the first non-blank character.
<S-Right> or
w	[count] words forward
<C-Right> or
W	[count] WORDS forward
e	Forward to the end of word [count]
E	Forward to the end of WORD [count]
<S-Left> or
b	[count] words backward
<C-Left> or
B	[count] WORDS backward
ge	Backward to the end of word [count]
gE	Backward to the end of WORD [count]
These commands move over words or WORDS.
A word consists of a sequence of letters, digits and underscores, or a sequence of other non-blank characters, separated with white space (spaces, tabs, ). This can be changed with the 'iskeyword' option.
A WORD consists of a sequence of non-blank characters, separated with white space. An empty line is also considered to be a word and a WORD.
(	[count] sentences backward
)	[count] sentences forward
{	[count] paragraphs backward
}	[count] paragraphs forward
]]	[count] sections forward or to the next '{' in the first column. When used after an operator, then the '}' in the first column.
][	[count] sections forward or to the next '}' in the first column
[[	[count] sections backward or to the previous '{' in the first column
[]	[count] sections backward or to the previous '}' in the first column
Marks

m{a-zA-Z}	Set mark {a-zA-Z} at cursor position (does not move the cursor, this is not a motion command).
m' or
m`	Set the previous context mark. This can be jumped to with the "''" or "``" command (does not move the cursor, this is not a motion command).
:[range]ma[rk] {a-zA-Z}	Set mark {a-zA-Z} at last line number in [range], column 0. Default is cursor line.
:[range]k{a-zA-Z}	Same as :mark, but the space before the mark name can be omitted.
'{a-z}	To the first non-blank character on the line with mark {a-z} (linewise).
'{A-Z0-9}	To the first non-blank character on the line with mark {A-Z0-9} in the correct file
`{a-z}	To the mark {a-z}
`{A-Z0-9}	To the mark {A-Z0-9} in the correct file
:marks	List all the current marks (not a motion command).
:marks {arg}	List the marks that are mentioned in {arg} (not a motion command). For example:
Searching

/{pattern}[/]	Search forward for the [count]'th occurrence of {pattern}
/{pattern}/{offset}	Search forward for the [count]'th occurrence of {pattern} and go {offset} lines up or down.
/<CR>	Search forward for the [count]'th latest used pattern
//{offset}<CR>	Search forward for the [count]'th latest used pattern with new. If {offset} is empty no offset is used.
?{pattern}[?]<CR>	Search backward for the [count]'th previous occurrence of {pattern}
?{pattern}?{offset}<CR>	Search backward for the [count]'th previous occurrence of {pattern} and go {offset} lines up or down
?<CR>	Search backward for the [count]'th latest used pattern
??{offset}<CR>	Search backward for the [count]'th latest used pattern with new {offset}. If {offset} is empty no offset is used.
n	Repeat the latest "/" or "?" [count] times.
N	Repeat the latest "/" or "?" [count] times in opposite direction.
Selecting Text (Visual Mode)

To select text, enter visual mode with one of the commands below, and use motion commands to highlight the text you are interested in. Then, use some command on the text.
The operators that can be used are:
  ~  switch case
  d  delete
  c  change
  y  yank
  >  shift right 
  <  shift left 
  !  filter through external command 
  =  filter through 'equalprg' option command 
  gq  format lines to 'textwidth' length 
v	start Visual mode per character.
V	start Visual mode linewise.
<Esc>	exit Visual mode without making any changes
How to Suspend

CTRL-Z	Suspend Vim, like ":stop". Works in Normal and in Visual mode. In Insert and Command-line mode, the CTRL-Z is inserted as a normal character.
:sus[pend][!] or
:st[op][!]	Suspend Vim. If the '!' is not given and 'autowrite' is set, every buffer with changes and a file name is written out. If the '!' is given or 'autowrite' is not set, changed buffers are not written, don't forget to bring Vim back to the foreground later!
* misc
** download youtube
http://en.savefrom.net/?rmode=false
* linux
** monitor
*** check system log
many logs are under the directory of /var/log/
and we could get the system log from /var/log/messages.
** performance
*** get process status
http://unix.stackexchange.com/questions/245827/spstack-ptrace-stopped-a-process
+ ps aux
+ grep State: /proc/the-pid/status. Is it State: T (stopped) or State:	t (tracing stop) ?
*** perf
perf record -g -e cpu-clock -p PID
https://perf.wiki.kernel.org/index.php/Main_Page
https://fritshoogland.wordpress.com/2013/11/24/when-the-oracle-wait-interface-isnt-enough/
*** ptrace/pstack
https://idea.popcount.org/2012-12-11-linux-process-states/
*** cgroup
https://en.wikipedia.org/wiki/Cgroups
* work
** TODO cr to read
FUS-12048 --- *important*
* youyou
13 - 5 = 8: 2015/12/6
* python
** scrapy
*** orc                                                               :orc:
https://webscraping.com/blog/Solving-CAPTCHA/
https://webscraping.com/blog/Automating-CAPTCHAs/
http://deathbycaptcha.com/user/faq
*** browsercookie                               :cookie:login:save:session:
Loads cookies from your browser into a cookiejar object so can download with urllib and other libraries the same content you see in the web browser.
https://pypi.python.org/pypi/browsercookie
https://bitbucket.org/richardpenman/browsercookie
*** How to crawl websites without being blocked

Speed
If you download 1 webpage a day then you will not be blocked but your crawl would take too long to be useful. If you instead used threading to crawl multiple URLs asynchronously then they might mistake you for a DOS attack and blacklist your IP. So what is the happy medium? The wikipedia article on web crawlers currently states Anecdotal evidence from access logs shows that access intervals from known crawlers vary between 20 seconds and 34 minutes. This is a little slow and I have found 1 download every 5 seconds is usually fine. If you don't need the data quickly then use a longer delay to reduce your risk and be kinder to their server.

Identity
Websites do not want to block genuine users so you should try to look like one. Set your user-agent to a common web browser instead of using the library default (such as wget/version or urllib/version). You could even pretend to be the Google Bot (only for the brave): Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)
If you have access to multiple IP addresses (for example via proxies) then distribute your requests among them so that it appears your downloading comes from multiple users.

Consistency
Avoid accessing webpages sequentially: /product/1, /product/2, etc. And don't download a new webpage exactly every N seconds. Both of these mistakes can attract attention to your downloading because a real user browses more randomly. So make sure to crawl webpages in an unordered manner and add a random offset to the delay between downloads.

Following these recommendations will allow you to crawl most websites without being detected.
*** Python Scrapy tutorial KeyError: 'Spider not found:
http://stackoverflow.com/questions/26359598/python-scrapy-tutorial-keyerror-spider-not-found
*** How to teach yourself web scraping



https://webscraping.com/blog/How-to-teach-yourself-web-scraping/

** database
*** postgresql
**** install python driver for postgresql
